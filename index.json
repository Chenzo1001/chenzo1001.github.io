[{"categories":null,"content":"CPU调度算法 CPU调度算法将一个任务的执行参数用四元数组表示：T(Q, P, E, D)。其中Q代表任务释放时间（Realease Time），P代表执行周期（Period）， E代表执行时间（Execution Time），D为周期内任务截止时间（Deadline）。 ","date":"2023-08-12","objectID":"/os/sched/:0:0","tags":["OSLearning"],"title":"CPU调度","uri":"/os/sched/"},{"categories":null,"content":"Deadline Monotonic CPU Scheduling （截止时间单调调度算法） DM算法的要求是所有硬时限任务必须在时限之前完成，每个任务具有固定的周期，并且任务互相独立。此算法根据任务的截止时间确定优先级。截止时间越靠前，优先级越高。高优先级的任务会对低优先级的任务进行抢占（preempt），确保任务能够及时完成。但是此算法对于可调度条件的计算复杂度较高。举例说明可以看GeeksForGeeks。 ","date":"2023-08-12","objectID":"/os/sched/:1:0","tags":["OSLearning"],"title":"CPU调度","uri":"/os/sched/"},{"categories":null,"content":"Earliest Deadline First（最早时限优先调度算法） EDF算法要求截止时限越靠近，任务优先级越高。但是EDF算法与DM算法的不同之处在于EDF算法不要求任务具有固定周期，根据任务的截止时间动态分配CPU资源。 优点 EDF算法的优越性在于灵活可变，不要求固定周期;调度效率较高，能够尽可能使用现有的资源。理论上EDF算法的CPU利用率能够达到100%。 ","date":"2023-08-12","objectID":"/os/sched/:2:0","tags":["OSLearning"],"title":"CPU调度","uri":"/os/sched/"},{"categories":null,"content":"Least-Slack-Time-First（最小空闲时间优先调度算法） LSF算法让CPU尽可能多运行，减少空闲时间以提高运用效率。任务所剩空闲时间越短，优先级越高。 缺点 LSF算法的缺点很明显。 CPU在运行时不可能只执行当前的任务。遇到有紧急任务分配时，CPU必须切换到其他的紧急任务上。执行完紧急任务之后，当前任务的剩余时间可能不足以执行完整个任务。 另外，一个任务在等待时，空闲时间是严格单调递减的。一个任务被执行时，等待任务的空闲时间递减。一旦少于当前执行任务的空闲时间时，CPU被该等待任务抢占。被抢占的任务空闲时间也会递减，这样该任务在一小段时间之后会反抢占CPU，导致频繁的任务切换。CPU的效率会因此大大降低。 ","date":"2023-08-12","objectID":"/os/sched/:3:0","tags":["OSLearning"],"title":"CPU调度","uri":"/os/sched/"},{"categories":null,"content":"关于define的使用 1.在c中是没有inline的。我们可以用define来取代简单inline函数的地位。 #define Square(l) ((l)*(l)) 2.define一个常量是不需要加等号的。加了等号，预定义的符号前面会带上等号。 3.可以发挥define空宏的解释性意义。比如下列代码： #define IN #define OUT #define OPTIONAL NTSTATUS NtLockFile( IN HANDLE FileHandle, IN HANDLE Event OPTIONAL, IN PIO_APC_ROUTINE ApcRoutine OPTIONAL, IN PVOID ApcContext OPTIONAL, OUT PIO_STATUS_BLOCK IoStatusBlock, IN PLARGE_INTEGER ByteOffset, IN PLARGE_INTEGER Length, IN ULONG Key, IN BOOLEAN FailImmediately, IN BOOLEAN ExclusiveLock ) 前缀IN，OUT，后缀OPTIONAL等等，在当时没有doxygen的情况下可以将函数参数的意义写清楚。 ","date":"2023-08-10","objectID":"/os/io/:0:0","tags":["OSLearning"],"title":"IO","uri":"/os/io/"},{"categories":null,"content":"思路 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:0:0","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"分类前处理 首先分析云层光谱特征，无论在高分影像上的哪个波段，云层的灰度值都比较高； 厚云很容易处理；对于薄云可以理解为在原来地物的基础上增加亮度，减少饱和度。为了方便研究云层的光谱特征，此处使用HSL色彩空间。因为HSL色彩空间能够很容易地处理图像上的饱和度和亮度。 同时，为了突出图像中的云层，发现云层一般具有亮度高而饱和度低的特征，可以使用公式L/S生成突出云层的一幅基底图。同时记得将数据进行归一化处理。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:1:0","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"分割提取云区 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:2:0","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"云区分割 现今比较优秀的分割算法有OTSU算法，Sauvola局部二值法等等。 相关知识 基于阈值的分割方法： 即先基于一幅图像计算两种或多种地物分类的阈值灰度，然后直接基于阈值对像素的灰度进行分类。常见的有直接阈值，迭代阈值，三角阈值，最大类间方差法（OTSU）（适用于全局分类）和Sauvola局部二值化算法（适用于局部分类）。依照字面意思都还比较好理解。 其中最大类间方差法就是使得类内方差降到最低，而类间方差达到最大，是现阶段被采用的比较多的一个方法，被认为是阈值分类的最佳方法。Sauvola局部二值化适用于某图像各个局部之间差异较大的情况。局部二值化是动态以每一个像素为中心点，对周围的像素进行分类。这能够很好地适应局部情况多变的状况。此时使用全局分类会导致某些局部的分类效果不佳，这时运用局部二值化就会得到优化。 然而OTSU算法用在薄云的检测中容易产生大量噪声点，并且基于单个像素的分类无法顾及周围像素的语义信息。因此引入面向对象的思想，使用SLIC算法均匀选定若干种子点，迭代出若干个超像素块，再对超像素块进行分类。 创新点 超像素块可以同时顾及周围像素的语义，使得同语义的像素聚合在一起;同时减少被分类的像素数量，加快分类的速度。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:2:1","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"排除人造地物干扰 对于若干房顶，水泥地等容易产生干扰的高亮地物，经过分析发现这类地物都具有较为明显的纹理特征。于是使用Gabor滤波排除这类人造地物的干扰。此处需要选定若干个不同方向的滤波器。 先生成若干个方向组合成的Gabor特征图，再采用特征图平滑，强调强线性特征区的明暗条纹；然后进行自动双阈值分割，采用经验阈值和OTSU算法分割。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:2:2","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"综合上述两个结果判断云区 综合光谱和纹理特征，确定判定法则，执行算法判断出云区和非云区。此处判定法则为： 1）若像素点在亮度阈值分割后被检测为非云，则为非云； 2）若亮度阈值分割判定为云，Gabor判定非云，则为非云； 3）两者判定均为云，则为云。 为了减少误判情况，判定之后可以采用带限定阈值的膨胀收缩运算，将影像分割为云区，非云区和待分类区域。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:2:3","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"基于图割模型的云区分割优化 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:3:0","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"经典图割模型 根据Ford and Fulkerson定理，最大流与最小割问题等价。于是可以使用最大流求解图像的最小割。图的权值使用能量函数进行判定。 能量函数有F^2与F^3两种。此处F2形式能量函数为：$ E(L_1,L_2，…,L_p)=\\sum_iE_i(L_i)+\\sum_{i\u003cj}E_{ij}(L_i,L_j) $ 依此构建出经典图割模型的能量函数：$ E(L)=\\lambda R(L)+\\Beta(L) $ 其中R（L）为区域项，B（L）为边界项。将前景和背景种子点集合分别作为图中的源点S和汇点T，确定每个像素点和S,T之间边的权值。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:3:1","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"改进经典图割模型 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:4:0","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"高斯混合模型替代直方图概率模型确定能量函数区域项 Boykov提出的经典模型中，使用直方图概率计算来确定待分类点被分类为前景和后景的惩罚项。而高斯混合模型相对于直方图概率计算，能够更好地描述颜色的变化，特别是微小的差异。所以利用高斯混合模型的方法构建云区和非云区的种子点，对 $ R_p(L_p) $ 的计算方法进行了改进。并且引入概率系数，增加像素标记为前景和背景的惩罚项的差距。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:4:1","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"引入边缘和纹理信息改进能量函数边界项 将所有波段全部引入色彩信息的计算。边缘检测可以用到梯度Sobel或Robert算子等离散型差分算子计算一阶导数 。其中值得注意的是，计算影像梯度值的基础上可以进行非极大值抑制，采用双阈值限定对检测出的梯度点进行重新筛选高于上限阈值的点为确定点，低于下限阈值的点直接淘汰，中间的点根据邻域关系进行判断。纹理特征的判断使用一种改进的HOG特征算子。 ","date":"2023-07-18","objectID":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/:4:2","tags":["SIDT AILab"],"title":"杨羚《基于多特征和图割模型的遥感影像云检测算法研究》笔记","uri":"/%E5%A4%9A%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E5%92%8C%E5%9B%BE%E5%89%B2%E6%96%B9%E6%B3%95%E4%BA%91%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"CMake笔记 1.CMakeLists.txt示例 cmake_minimum_required (VERSION 3.0) SET (CMAKE_C_COMPILER D:/Qt/Tools/mingw1120_64/bin/gcc.exe) SET (CMAKE_CPP_COMPILER D:/Qt/Tools/mingw1120_64/bin/g++.exe) project(WCAS) set(CMAKE_INCLUDE_CURRENT_DIR ON) SET (CMAKE_AUTOMOC ON) SET (CMAKE_AUTORCC ON) SET (CMAKE_AUTOUIC ON) SET (CMAKE_CXX_STANDARD 17) SET (CMAKE_CXX_STANDARD_REQUIRED ON) find_package(Qt6 COMPONENTS Widgets REQUIRED) find_package(Qt COMPONENTS sql REQUIRED) set(CMAKE_PREFIX_PATH D:/Qt/6.4.1/mingw_64) SET (ui ./src/selflightdlg.ui) SET(src ./src/WCAS.cpp) SET(incl ./inc/ensuredlg.h) include_directories(inc) QT6_WRAP_UI(uic ${ui}) QT6_WRAP_CPP(HEAD ${incl}) QT6_ADD_RESOURCES(qrcs ./pic/Resource.qrc) INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}) add_executable (WCAS ${HEAD} ${uic} ${qrcs} ${src}) target_link_libraries(${PROJECT_NAME} Qt6::Widgets) 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 ","date":"2023-03-15","objectID":"/cmake/:0:0","tags":["Notes"],"title":"CMake Notes","uri":"/cmake/"},{"categories":null,"content":"1.文件读写fstream fstream成员函数： 读取或写入指针设置函数void seekg(long position,ios::end/beg/cur)和void seekp(long position,ios::end/beg/cur) 读取或写入指针读取函数long tellg()和long tellp(),相对于文件头输出字符 现声明一个fstream类实例f: ","date":"2023-03-15","objectID":"/cpp/:1:0","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"1.读取文件内容: 1.f.read(char* buff,size_t position);可以将本来不是字符型数据的指针做指针强制转换. 2.流读取»,这个以一个空格为分界点. 3.f.getline(char* buff,size_t length);这是一行一行读取的,遇到\\n换行符即停止读取.可以使用:while(f.getline(tmp, size))来读取.除非到末尾,否则getline的结果一直为true(但是getline的返回值类型并不是bool) ","date":"2023-03-15","objectID":"/cpp/:1:1","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"2.写入文件内容 1.f.write(char* buff, size_t length)和read函数是一个意思. 2.流写入«,这个直接将前面给出的内容一口气写完. 2、数据类型转换 ","date":"2023-03-15","objectID":"/cpp/:1:2","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"string和int,double等 int atoi(str.c_str()); double atof(str.c_str()); string str = std::to_string(number) 这里不管是int还是double还是long，unsigned等等都可以使用.要记得 #include \u003cstring\u003e ","date":"2023-03-15","objectID":"/cpp/:2:0","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"char*和string string str=ch; char* ch=str.c_str(); 三.加密算法 ","date":"2023-03-15","objectID":"/cpp/:3:0","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"1.AES算法全流程： ","date":"2023-03-15","objectID":"/cpp/:4:0","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"1.预备知识: AES算法需要如下储备: S盒代换表和逆S盒代换表 密钥拓展所用的轮常量 16个1 Byte hex密钥(可自定义) 列混合的矩阵 AES加密对数据具有要求,即数据的长度必须为128或160或192bit.即16字节或20字节或24字节.对于所有的数据(包括位数正好16位的),AES算法提供几种填充方式.一般使用ISO 10126填充办法.即非最后一位填随机数,最后一位填上所有被填充数据的位数. AES加密中,所有的矩阵相乘都用的是GF(2^8)下的乘法.具体算法如下: 1.定义函数f,使得f(a)=2*a.但是a不得超过2^8,超过的话就mod0x100,然后和0x1b异或. 2.一个数a乘以十六进制的另一个数b,如果b等于1,则结果为a,如果b等于2^n,则结果为f(f(f…(a)…))迭代n次.如果b不等于以上任何一种情况,那么将b拆成以上2的各个n次方的和,然后a各与这些2的n次方相乘之后,将所有结果异或,得最终结果. ","date":"2023-03-15","objectID":"/cpp/:4:1","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"2.加密流程: 1.密钥拓展 unsigned short int num = 16; while (num \u003c 176) { if (num % 16 == 0) { unsigned short int tmp = key[num]; key[num] = key[num + 1]; key[num + 1] = key[num + 2]; key[num + 2] = key[num + 3]; key[num + 3] = tmp; for (int i = num; i \u003c num + 4; i++) { key[i] = sbox[key[i] \u0026 0xff] ^ con[(num - 16) / 4 + i - num + 1]; key[i] = key[i] ^ key[i - num]; } num += 4; } else { key[num] = key[num - 4] ^ key[num - 16]; num++; } } 2.S盒代换 根据S盒表,将两位hex数字作为坐标,代换S盒的坐标上的结果. 3.行位移 移动前:———————–移动后 1 2 3 4—————-1 2 3 4 5 6 7 8—————-6 7 8 5 9 10 11 12————11 12 9 10 13 14 15 16———–16 13 14 15 4.列混合 列混合矩阵mix左乘传入的数据mes.左乘的运算规则和线代的矩阵左乘是一样的,但是乘法改为GF(2^8)上的乘法,加法改为异或. 附:矩阵左乘运算代码: short int result[16]; // 对于被左乘的矩阵mes，m列i行 for (int m = 0; m \u003c 4; m++) { for (int i = 0; i \u003c 4; i++) result[4 * m + i] = mes[4 * m]*mix[i]; for (int i = 1; i \u003c 4; i++) for (int j = 0; j \u003c 4; j++) result[4 * m + j] += mes[4 * m + i]*mix[4 * i + j]; } for (int i = 0; i \u003c 16; i++) mes[i] = result[i]; 5.轮密钥加 即传入的数据矩阵和密钥矩阵进行异或.第n轮就和第n次密钥拓展的结果矩阵进行异或. 6.AES加密. AES加密时先进行第0轮轮密钥加,然后再循环9次: S盒代换 行位移 列混合 轮密钥加 最后第11轮,重复上述操作,但是不进行列混合,最后输出结果。 7.AES解密 AES解密的流程完全与加密流程相反，只是S盒使用逆代换表，列混合使用逆列混合矩阵。 递归将字符串倒序 如果是char字符串：从头向尾翻转 void reverse(char *s) { if (*s) { char *p = s; char c = s[0]; do {*p = *(p+1); p++;}while(*p); reverse(s); s[strlen(s)] = c; } } 如果用string串：从中间向两边翻转 void reverse(string\u0026 s) { size_t length = s.length(); if (length == 0 || length == 1) return; char s0 = s[0]; char sl = s[length - 1]; string p(s, 1, length - 2); reverse(p); s = sl + p + s0; return; } 小细节问题 1.要记得m«2是一个运算式，并不是一个操作符。这个移位并不会将m向高位移动2bit。 2.string的一个大坑点：在普通情况下，一般char数组是不会存入一些特殊字符的。这个时候char数组转string就没有什么问题。但是在设计加密解密的时候，有时候程序读取的是一些杂乱字符。这个时候char数组里面可能会存有’\\0’(char 0)数据。而string=char[]在赋值的时候，默认以’\\0’作为结束符。这就导致解密算法程序的string会偏小。这时需要强制赋值: string str(char* ch, size_t length); 这个函数不会考虑数组越界问题。有可能将内存里面一些本来不属于char数组的东西给拷进去. 3.在赋值的时候,一定要注意两个数据的字节大小孰高孰低.如果是低转高,最好使用\u0026取出低字节类型的数据.比如说int= string.c_str()[i]时,int的字节较高,而string转换过来的char数组字节较低.此时int比char高的字节有可能会被char存储一些无用的填充数据.这个时候最好改为:int=string.c_str()[i]\u00260xff,保证高字节是0. 4.关于运算表达式的问题:cout \u003c\u003c (b=n)结果为n.也就是说,如果使用if(b=n)表达式,那么这个表达式相当于先b=n,然后再if(n).n等于0的话就跳过if.并不是说表达式本身的结果为1. 5.\u0026\u0026和||具有短路特性！(a==1)\u0026\u0026(++b==1)如果a!=false，那么b就不会再执行++操作。a||b同理，这个要特别注意. 6.sizeof 表达式表示表达式的结果所占的字节数. 7.cout的setsprecision(n),是指包括小数点的后n位！也就是保留n-1位小数. 8.下面运行的程序，输入“(两个空格)as as”会输出“as as” cin \u003e\u003e ws;//略过空格 getline(cin, s); cout \u003c\u003c s; 9.默认形参如果在函数声明中给出，那么在函数定义中就不能再给出默认形参！ int add(int x=5, int y=5);//声明中给出了默认形参 ... int add(int x/*=5*/, int y/*=5*/) //这里就不能再给默认形参了！ { //函数定义 } 声明在前，则必须声明给出默认函数值。声明没给，则定义就不能给。 10.如果一个函数仅以有没有const属性为区别进行重载，那么非常对象调用这个函数时会匹配到没有const属性的那个重载函数。 11.友元关系不能传递和继承，单向起作用。 12.非const的引用只能绑定到普通对象，不能到常对象。 13. typedef char* pstr; const pstr p;//他不等于const char* pstr！！ 这说明pstr是一个指向char类型的常量指针，而不是指向char常量的指针！！ const int* p指向int常量的指针 int* const p指向int的常量指针 14.decltype(i)j=2;初始化j的值为2，j的类型和i一致。 15.关于const_cast的操作：如果一个变量一开始就声明为const数组，初始化存入了一些数据，那么这一块内存就已经被定为了只读内存，就算你用const_cast去修改指针，你也无法改动这块的数据。但是如果给一个形参为const char*的函数传入了非const变量，那么这个const属性是函数给的，并不是内存具有的，所以可以在函数内执行const_cast来去除const属性并且进行修改。 16.如果派生类定义了一个与基类成员同名的成员函数，不管两个函数的参数表是否相同，基类的所有重载函数都会被隐藏。解决办法是使用USING。 17.成员函数重载运算符与非~的一个区别在于，成员运算符的左操作数不能实现隐含转换，因为左操作数是调用对象，没办法隐含转换。 ","date":"2023-03-15","objectID":"/cpp/:4:2","tags":["Notes"],"title":"CPP Notes","uri":"/cpp/"},{"categories":null,"content":"1.AES加密开发笔记: ","date":"2023-03-15","objectID":"/%E5%BF%83%E5%BE%97/:0:0","tags":["Notes"],"title":"Program Developing Notes","uri":"/%E5%BF%83%E5%BE%97/"},{"categories":null,"content":"1.程序开发前: 在开发程序的时候一定要先在本子上画好框架，然后划分部分，每个部分需要实现什么样的功能。如果可以的话，再加上具体的函数功能什么的。在开头就想好了框架划分的话，开发的时候就会快速一些。 开发的时候，需要在函数的定义之前增加注释，简短做一些对于函数的解释。本次开发程序过程中，原本开发出了一个string aesencode(string)函数，在函数体里面就已经考虑过了对于传入信息的拆分，加密和整合。但是在后续开发over-32kb程序的时候，又将拆分等等问题考虑了一遍，导致程序读取和写入的数据发生错位，浪费了一些时间。 在本该实现的功能开发完之后，如果想以此为基础继续添加功能，改进程序等等，一定要记得之前写出来的函数或者类的作用以及一些限定条件。 ","date":"2023-03-15","objectID":"/%E5%BF%83%E5%BE%97/:1:0","tags":["Notes"],"title":"Program Developing Notes","uri":"/%E5%BF%83%E5%BE%97/"},{"categories":null,"content":"2.程序开发中： 最好在开发程序(尤其是设计算法)的时候加上debug output。debug output应该要有固定的格式。 遇到问题的时候不要烦躁，观察debug output要比手设断点然后去查内存要方便一些。 开发程序的过程中，最好养成对某一项的值进行合法性判断的习惯。比如一个值本来只能取0-16，可以在获取值之后紧跟if然后甩出cerr的方法 分析出错的思路的时候不要着急,一步一步慢慢来. 代码一定要保持整洁.对函数和变量的命名要准确.然后不要乱用goto. 对于自己开发整个程序框架,而不是自己写出函数供别人使用的话,最好在出错的时候直接抛出错误,而不是返回错误码.一可以提高主框架的整洁性,二也可以方便查错. ","date":"2023-03-15","objectID":"/%E5%BF%83%E5%BE%97/:2:0","tags":["Notes"],"title":"Program Developing Notes","uri":"/%E5%BF%83%E5%BE%97/"},{"categories":null,"content":"1.SQL数据库的创建 2.SQL表格创建 CREATE TABLE XX( ID int not null, name varchar(50) not null ... ) 3.Qt链接SQL数据库 1.需要加入sql包 ","date":"2023-03-15","objectID":"/sql/:0:0","tags":["Notes"],"title":"SQL Notes","uri":"/sql/"},{"categories":null,"content":"About CCY ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]